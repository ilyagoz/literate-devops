#+TITLE: Файл конфигурации почтового сервера Exim
#+SETUPFILE: ~/.emacs.d/org-themes/src/readtheorg_inline/readtheorg_inline.theme
#+PROPERTY: header-args  :tangle exim.j2  :comments no
#+LANGUAGE: Russian
#+LATEX_HEADER: \usepackage[english,russian]{babel}

* Предисловие

Этот файл был взят из исходных кодов Exim 4.94.2, из каталога =src/configure.default= и переведен в формат =org-mode=.

По сравнению с конфигурацией по умолчанию в него внесено несколько модификаций.

- Параметр =received_header_text= задан пустой строкой. Поэтому заголовки Received: к письмам добавляться не будут. В конфигурации по умолчанию они содержат информацию об именах хостов во внутренней сети, версии Exim и т.д.
- Добавлен маршрутизатор =smarthost_multi=, выбирающий транспорт в зависимости от идентификатора пользователя.
- Добавлены транспорты для доставки сообщений на смарт-хосты по правилам маршрутизации в зависимости от отправителя, если сработал маршрутизатор =smarthost_multi=.
- Добавлены аутентификаторы для этих смарт-хостов.

Полный список всех параметров конфигурации времени выполнения, которые могут быть включены в файл конфигурации, см. в руководстве. Их гораздо больше, чем упомянуто здесь. Руководство находится в файле =doc/spec.txt= в дистрибутиве Exim в виде обычного файла ASCII.  Другие форматы (PostScript, Texinfo, HTML, PDF) доступны на ftp-сайтах Exim. Руководство также находится онлайн на веб-сайте Exim.

Этот файл разделен на несколько частей, каждая из которых, кроме первой, начинается строкой, начинающейся со слова =begin=. Обязательно должны присутствовать только те части, которые указаны в качестве необходимых. Пустые строки и строки, начинающиеся с #, игнорируются.

* Макросы

Если вы хотите использовать смарт-хост вместо отправки напрямую на домены получателей, раскомментируйте это определение макроса и впишите реальное имя смарт-хоста. В случае необходимости пользователь с соответствующими правами может перенаправить электронную почту с помощью опции командной строки =-D=.

#+begin_src jinja2
  # ROUTER_SMARTHOST=MAIL.HOSTNAME.FOR.CENTRAL.SERVER.EXAMPLE
  CONFDIR = {{ CONFDIR }}
#+end_src

* Основные настройки

По умолчанию exim считает печатаемыми только те символы, чьи коды лежат в диапазоне 32-126. В ряде случаев (например, при записи в журнал) непечатаемые символы преобразуются в escape-последовательности, в первую очередь, чтобы не испортить вид. Если установлен параметр =print_topbitchars=, кодовые значения 128 и выше также считаются печатаемыми символами.

Эта опция также влияет на проверки синтаксиса заголовка, выполняемые транспортом =autoreply=, и на то, использует ли Exim кодировку RFC 2047 для полного имени пользователя при построении адресов From: и Sender: (как описано в разделе 48.18). Установка этой опции может заставить exim генерировать восьмибитные заголовки сообщений, которые не соответствуют стандартам.

#+begin_src conf-unix
print_topbitchars = true
#+end_src

Эта опция содержит строковый список переменных окружения, которые
необходимо сохранить. Вы должны доверять этим переменным или должны
быть уверены, что эти переменные не создают угрозы
безопасности. Имейте в виду, что в большинстве установок на этапе
запуска Exim работает с эффективным UID 0 . Поскольку значением по
умолчанию является пустой список, окружение по умолчанию для
использования библиотек, запуска встроенного кода Perl или запуска
внешних двоичных файлов пусто и даже не содержит PATH или HOME.

На самом деле список интерпретируется как список шаблонов (10.1), за
исключением того, что он сначала не расширяется.

ВНИМАНИЕ: Сначала выполняется подстановка макросов, поэтому если у вас
будет макрос =FOO=, а в параметре =keep_environment= будет строка
=FOO_HOME=, результат может оказаться неожиданным. Это можно обойти,
используя регулярное выражение, которое не совпадает с именем макроса:
=^[F]OO_HOME$=.

Текущие версии Exim выдают предупреждение, если в файле конфигурации
времени выполнения нет параметра =keep_environment= и если текущее
окружение не пусто.  Будущие версии, возможно, не будут выдавать это
предупреждение.

#+begin_src conf-unix
keep_environment =
#+end_src

Укажите здесь каноническое имя вашего хоста.  Обычно это полное «официальное» имя вашего хоста. Если этот параметр не установлен, для получения имени вызывается функция =uname()=. Во многих случаях это правильно, и вам не нужно ничего явно задавать.

#+begin_src conf-unix
# primary_hostname =
#+end_src

Эта строка определяет содержимое заголовка сообщения Received:, который добавляется к каждому сообщению, за исключением метки времени, которая автоматически добавляется в конце (перед которой ставится точка с запятой). Строка расширяется каждый раз, когда она используется. Если расширение дает пустую строку, строка заголовка Received: не добавляется к сообщению. В противном случае строка должна начинаться с текста «Received:» и соответствовать спецификации RFC 2822 для строк заголовков Received:.

#+begin_src conf-unix
received_header_text = 
#+end_src

Следующие три параметра создают два списка доменов и один список хостов. Эти списки упоминаются позже в этой конфигурации с использованием синтаксиса =+local_domains=, =+relay_to_domains= и =+relay_from_hosts= соответственно. Все они -- списки, разделяемые двоеточием:

#+begin_src conf-unix
  domainlist local_domains = @
  domainlist relay_to_domains =
  hostlist   relay_from_hosts = localhost
#+end_src

(Мы рассчитываем, что разрешение имени хоста будет работать для =localhost=, потому что конфигурация по умолчанию должна работать при наличии только IPv4.)

В простых случаях для управления доступом можно использовать вышеуказанные параметры. В более сложных ситуациях придется редактировать списки контроля доступа (ACL), которые будут приведены ниже в этом файле.

Первый параметр -- это список локальных доменов, например:
  
     =domainlist local_domains = my.first.domain : my.second.domain=
  
Можно использовать "=@=" для обозначения "имени локального хоста", как в настройке по умолчанию выше. Это имя, заданное параметром =primary_hostname=, как указано выше (или взятое по умолчанию). Если вы не хотите выполнять локальную доставку почты, удалите "=@=" из настройки выше. Если вы хотите принимать почту, направленную по "буквальному" IP-адресу вашего хоста (literal domain), например, по адресу "=user@[192.168.23.44]=", добавьте "=@[]=" в качестве элемента в список локальных доменов. Нужно будет также раскомментировать "=allow_domain_literals=" ниже. В современном Интернете делать это не рекомендуется.
   
Второй параметр указывает домены, на которые ваш хост выполняет ретрансляцию. Если вы не выполняете никакой ретрансляции, нужно оставить список пустым. Однако, если ваш хост является резервным MX или шлюзом для каких-то доменов, нужно вписать в =relay_to_domains= эти домены. Например:

   =domainlist relay_to_domains = *.myco.com : my.friend.org=
  
Это позволит любому хосту ретранслировать через ваш хост почту на эти домены. Дополнительную информацию см. в разделе руководства «Управление ретрансляцией».

Третий параметр указывает хосты, которым разрешено использовать ваш хост в качестве исходящего ретранслятора для любого другого хоста в Интернете. Здесь обычно указывается вся локальная сеть, а также локальный хост. Например:
  
   =hostlist relay_from_hosts = <; 127.0.0.1 ; ::1 ; 192.168.0.0/16=
  
"=/16=" — это битовая маска (в формате CIDR), а не количество хостов. Обратите внимание, что нужно указать =127.0.0.1=, если вы хотите разрешить процессам на вашем хосте отправлять почту SMTP с использованием loopback-адреса. Ряд MUA используют этот метод отправки почты. Часто соединения устанавливаются на =localhost=, что на хостах с поддержкой IPv6 может соответствовать =::1= . Не забудьте про CIDR для сетей IPv6.
   
Все три нижеследующих списка могут содержать множество различных типов элементов, включая имена с шаблонами, регулярные выражения и выражения для поиска в файлах. Подробнее см. в руководстве. Приведенные выше списки используются в списках контроля доступа для проверки входящих сообщений. Имена этих ACL определены здесь:

#+begin_src conf-unix
  acl_smtp_rcpt =         acl_check_rcpt
  .ifdef _HAVE_PRDR
  acl_smtp_data_prdr =    acl_check_prdr
  .endif
  acl_smtp_data =         acl_check_data
#+end_src

Не стоит изменять эти настройки, если вы не разбираетесь в том, как работают ACL.

Если вы используете версию Exim, которая была скомпилирована с расширением для сканирования контента, вы можете автоматически проверять входящие сообщения на наличие вирусов. Для этого придется изменить конфигурацию в двух местах. Первое --  здесь, где  определяется интерфейс для сканера. Этот пример подходит для ClamAV; в руководстве приведена более подробная информация о том, как настроить интерфейс для других антивирусных сканеров. Вторую модификацию нужно сделать в списке управления доступом acl_check_data (см. ниже).

#+BEGIN_src conf-unix
  # av_scanner = clamd:/tmp/clamd
#+end_src

Для проверки на спам существует аналогичный параметр, определяющий интерфейс для SpamAssassin. Вам не нужно его устанавливать, если интерфейс настроен со значениями по умолчанию, как в закомментированном примере. Как и при проверке на вирусы, нужно будет также  изменить список управления доступом acl_check_data.

#+begin_src conf-unix  
  # spamd_address = 127.0.0.1 783
#+end_src

Если Exim скомпилирован с поддержкой TLS, то чтобы Exim позволял клиентам устанавливать зашифрованные соединения, нужно включить следующие опции. В разделе аутентификаторов ниже есть конфигурации шаблонов для аутентификации по имени пользователя/паролю с открытым текстом. Этот тип аутентификации безопасен только при использовании в соединении TLS, поэтому аутентификаторы будут работать, только если  следующие опции TLS включены.

Разрешить любому клиенту использовать TLS.

#+begin_src conf-unix  
  tls_advertise_hosts = *
#+end_src

Использовать любые шифры на порту 25, использовать только хорошие шифры на порту 587.

#+begin_src conf-unix  
  tls_require_ciphers = ${if =={$received_port}{25} \
				  {DEFAULT} {HIGH:!MD5:!SHA1:!SHA2}}
#+end_src

Укажите расположение TLS-сертификата и закрытого ключа сервера Exim. Закрытый ключ не должен быть зашифрован (защищен паролем). Вы можете поместить сертификат и закрытый ключ в один и тот же файл, и в этом случае вам понадобится только первая настройка, или в отдельные файлы, и в этом случае вам понадобятся обе.

#+begin_src conf-unix  
  tls_certificate = {{ TLS_CERTIFICATE }} 
  tls_privatekey = {{ TLS_PRIVATEKEY }}
#+end_src

Если используется OpenSSL, следует предпочитать шифры с аутентификацией EC, а не RSA.
#+begin_src conf-unix  
  # tls_require_ciphers = ECDSA:RSA:!COMPLEMENTOFDEFAULT
#+end_src

Мобильные пользователи могут отправлять электронную почту откуда угодно. На случай, если им необходимо отправлять электронную почту из сети, которая блокирует порт 25, можно сделать так, чтобы Exim наряду с портом 25 прослушивал другие порты.  Стандартный порт для этого 587, порт "отправки сообщений" (message submission). Подробности см. в RFC 4409. Почтовые клиенты Microsoft не всегда настроены на правильное использования протокола message submission, поэтому, если вам необходимо их поддерживать, нужно также разрешить TLS-on-connect на традиционном, но нестандартном порту 465.

#+begin_src conf-unix
  daemon_smtp_ports = 25 : 465 : 587
  tls_on_connect_ports = 465
#+end_src

Если вы хотите, чтобы неполные адреса получателей дополнялись доменом, отличным от домена, которым дополняются неполные адреса отправителя, укажите здесь домен получателя. Если этот параметр не установлен, используется значение =qualify_domain=.

#+begin_src conf-unix
  # qualify_recipient =
#+end_src

Если вы хотите, чтобы Exim распознавал адреса вида "=user@[10.11.12.13]=", то есть с "буквальным доменом" (IP-адресом) вместо именованного домена, то следующую строку нужно раскомментировать. В RFC эта форма сохранилась, но в современном Интернете нет смысла разрешать отправку почты на хосты по их IP-адресам. Этот старый формат использовался, в том числе, для ретрансляции почты через хосты в обход разрешений. Если вы действительно хотите поддерживать буквальные домены, раскомментируйте следующую строку и настройте маршрутизатор =domain_literal= ниже.

#+begin_src conf-unix
  # allow_domain_literals
#+end_src

Доставки не будут выполняться под uid пользователей, указанных в списке =never_users= (это список, разделенный двоеточиями). Попытка сделать это приводит к регистрации ошибки и отсрочке доставки. Это параноидальный предохранитель. Существует еще более надежный предохранитель в виде настройки =FIXED_NEVER_USERS= в конфигурации сборки Exim. Этот список пользователей встроен в двоичный файл и не может быть изменен. Настройка ниже просто добавляет дополнительных пользователей в список. Значением по умолчанию для =FIXED_NEVER_USERS= является =root=, но на всякий случай здесь по умолчанию также используется значение =root=.

Обратите внимание, что настройка по умолчанию означает, что почту,
адресованную пользователю =root=, нельзя доставлять так же, как
обычным пользователям. Обычно это не проблема, так как в большинстве
систем для =root= настраивается почтовый псевдоним, который
перенаправляет такую почту администратору-человеку.

#+begin_src conf-unix
  never_users = root
#+end_src

Настройка ниже заставит Exim выполнять обратный поиск DNS для всех входящих соединений по IP, чтобы получить истинное имя хоста. Если вы считаете, что это слишком накладно, вы можете указать сети, для которых выполняется поиск, или полностью удалить настройку.

  #+begin_src conf-unix
  # host_lookup = *
  #+end_src

Настройка ниже заставит Exim попытаться инициализировать системную библиотеку разрешения имен с поддержкой DNSSEC. Она не сработает, если в вашей библиотеке отсутствует поддержка DNSSEC.

  #+begin_src conf-unix
  dns_dnssec_ok = 0
  #+end_src

Приведенные ниже настройки заставляют Exim выполнять обратные вызовы RFC 1413 (ident) для всех входящих соединений по SMTP. Вы можете указать хосты, для которых эти вызовы будут делаться, и/или изменить время ожидания. Если вы установите время ожидания равным нулю, все вызовы RFC 1413 будут отключены. Для вызовов RFC 1413 не нужно много ресурсов и они могут предоставить полезную информацию для отслеживания проблемных писем, но у некоторых хостов и брандмауэров с ними возникают проблемы. Это может привести к тайм-ауту вместо немедленного отказа в подключении, что приведет к задержкам при запуске сеансов SMTP. (Значение по умолчанию было уменьшено с 30 до 5 с в версии 4.61 и  до 0 (отключено) в версии 4.86.)
  
  #+begin_src conf-unix
  #rfc1413_hosts = *
  #rfc1413_query_timeout = 5s
  #+end_src

Включить функцию Per-Recipient Data Response. Мы сообщаем об этой функции; клиенты могут запросить ее использование. Если она используется, то сообщения с несколькими получателями мы можем отклонять или принимать отдельно для каждого пользователя после получения сообщения. Так можно организовать фильтрацию сообщений в зависимости от получателя. Без этой функции пришлось бы временно отклонять всех получателей после первого с несовместимой фильтрацией, и выполнять фильтрацию в ACL данных. Даже если она включена, нужно поддерживать старый стиль для узлов, не запрашивающих поддержку PRDR (указывается в =$prdr_requested=).
  
  #+begin_src conf-unix
  .ifdef _HAVE_PRDR
  prdr_enable = true
  .endif
  #+end_src

  #+begin_src conf-unix
      local_from_check = false
      local_sender_retain = true
      untrusted_set_sender = *
  #+end_src
  
По умолчанию Exim ожидает, что все адреса будут полными, то есть содержащими как локальную часть, так и домен. Если вы хотите принимать от определенных хостов неполные адреса (только с локальной частью), вы можете указать эти хосты в следующих настройках:
  
	,#+begin_src conf-unix
	# sender_unqualified_hosts =
	# recipient_unqualified_hosts =
  #+end_src
  
для адресов отправителя и получателя соответственно. Если это сделано, неполные адреса дополняются с использованием настроек =qualify_domain= и/или =qualify_recipient= (см. выше).

Если только вы не работаете с большим объемом почты, вам, вероятно, подойдет более подробный журнал, чем по умолчанию. Настройте по желанию.

#+begin_src conf-unix
  log_selector = +smtp_protocol_error +smtp_syntax_error \
	       +tls_certificate_verified
#+end_src

Если вы хотите, чтобы Exim поддерживал «процентный хак» для
определенных доменов, раскомментируйте следующую строку и укажите
список доменов. «Процентный хак» — это функция, с помощью которой
почта, адресованная =x%y@z= (где =z= — один из перечисленных доменов),
локально перенаправляется на =x@y= и отправляется дальше. Если =z= не
является одним из доменов «процентного хака», =x%y= рассматривается
как обычная локальная часть. В настоящее время этот хак редко бывает
нужен; не надо включать его, если вы не уверены, что он вам
действительно нужен.
  
  #+begin_src conf-unix
  # percent_hack_domains =
  #+end_src
  
Помимо установки этого параметра, потребуется также удалить проверку содержания % в локальных частях в определении ACL ниже.

Если Exim не может ни доставить сообщение, ни вернуть его отправителю, он "замораживает" сообщение об ошибке доставки (bounce message). Есть и другие обстоятельства, при которых сообщения замораживаются. Они останутся в очереди навсегда, если не установлен один из следующих параметров.

Этот параметр размораживает замороженные сообщения о возврате через два дня, пытается еще раз их доставить и игнорирует любые сбои доставки.

  #+begin_src conf-unix
  ignore_bounce_errors_after = 2d
  #+end_src

Эта опция отменяет (удаляет) замороженные сообщения старше недели.

  #+begin_src conf-unix
  timeout_frozen_after = 7d
  #+end_src

По умолчанию, все сообщения, ожидающие в очереди Exim, хранятся в единственном каталоге под названием =input=, который сам находится в каталоге спула Exim. (Каталог спула по умолчанию указывается при сборке Exim, обычно это =/var/spool/exim/=.) Exim работает лучше всего, если его очередь не очень длинная, но в некоторых обстоятельствах это невозможно. Если вы раскомментируете приведенный ниже параметр, сообщения в очереди будут храниться в 62 подкаталогах =input=, а не в одном каталоге. Подкаталоги называются 0, 1, ... A, B, ... a, b, ... z. Это дает два преимущества: (1) снижается вероятность ухудшения работы файловой системы ухудшается из-за большого количества файлов в одном каталоге; (2) Exim может обрабатывать очередь по одному подкаталогу за раз, а не все сразу, что может повысить производительность при обработке длинных очередей.

  #+begin_src conf-unix
  # split_spool_directory = true
  #+end_src

Если вы живете в той части мира, где кодировки ASCII для текстов недостаточно, то вы, вероятно, знакомы с расширениями для заголовков сообщений RFC2047. По умолчанию Exim придерживается этого стандарта, включая ограничение в 76 символов в строке, чтобы закодированные слова помещались в одну строку. Если вы хотите использовать декодированные заголовки в фильтрах сообщений и при этом важно успешное декодирование неправильно сформированных сообщений, можно сделать поведение Exim менее строгим.
  
  #+begin_src conf-unix
  # check_rfc2047_length = false
  #+end_src
  
В поддержку Exim поступали многочисленные сообщения от российских администраторов о проблемах с проверкой длины закодированных слов из-за одной популярной, но глючной почтовой программы.

Если вы хотите строгого соответствия RFC или знаете, что вам предстоит обмениваться почтой с системами, которые не поддерживают 8-битную кодировку, вы можете отключить поддержку 8BITMIME. Для этого раскомментируйте этот параметр.

  #+begin_src conf-unix
  # accept_8bitmime = false
  #+end_src

Exim сам по себе не использует переменные окружения. Однако библиотеки, которые использует Exim (например, LDAP), зависят от конкретных настроек среды. Есть два списка: =keep_environment= для переменных, которым мы доверяем, и =add_environment= для переменных, которым мы хотим присвоить определенное значение. Обратите внимание, что TZ обрабатывается отдельно параметром часового пояса и параметром =TIMEZONE_DEFAULT= при сборке.

  #+begin_src conf-unix
  # keep_environment = ^LDAP
  # add_environment = PATH=/usr/bin::/bin
  #+end_src
  
* Конфигурация списков контроля доступа (ACL)
  
Определяет списки контроля доступа для входящей почты SMTP.
   
#+begin_src conf-unix
begin acl
#+end_src

** Cписок контроля доступа =acl_check_rcpt=

Этот список контроля доступа используется для каждой команды RCPT во входящем SMTP-сообщении. Тесты выполняются по порядку до тех пор, пока адрес не будет либо принят, либо отклонен.

#+begin_src conf-unix
acl_check_rcpt:
#+end_src

Принять, если источником является локальный SMTP (т.е. не через TCP/IP). Мы делаем это, проверяя, не пусто ли имя отправляющего хоста.

#+begin_src conf-unix
  accept  hosts = :
          control = dkim_disable_verify
#+end_src

В следующем разделе ACL рассматриваются локальные части, которые содержат =@= или =%= или =!= или =/= или =|= или точки в необычных местах.
  
Символы, отличные от точек, редко встречаются в настоящих локальных частях, но их часто пытаются использовать люди, желающие обойти ограничения на ретрансляцию. Поэтому, хотя такие символы могут появляться в локальных частях, эти правила на всякий случай блокируют их.
  
Пустые компоненты (две точки подряд) не соответствуют RFC 2822, но Exim разрешает их, потому что они встречаются. (Возьмем, например, локальную часть, создаваемую по шаблону "=firstinitial.secondinitial.familyname=", и попробуем применить шаблон ко мне. В моем имени нет второго инициала.)  Однако локальная часть, начинающаяся с точки или содержащая =/../=, может привести к проблемам, если будет использоваться как часть имени файла (например, для списка рассылки). Это также верно для локальных частей, содержащих косую черту. Символ вертикальной черты также может вызвать проблемы, если локальная часть будет неосторожно включена в командную строку оболочки.
  
Используются два разных правила. Первое - более строгое и применяется к сообщениям, адресованным одному из локальных доменов, обрабатываемых этим хостом. Строка =domains = +local_domains= ограничивает его доменами, которые определены параметром =domainlist local_domains= выше. Правило блокирует локальные части, которые начинаются с точки или содержат =@= =%= =!= =/= или =|=.  Если у вас есть локальные учетные записи, содержащие эти символы, вам придется изменить это правило.
  
#+begin_src conf-unix
  deny    message       = Restricted characters in address
          domains       = +local_domains
          local_parts   = ^[.] : ^.*[@%!/|]
#+end_src

Второе правило применяется ко всем другим доменам и является менее строгим.  Строка =domains = !+local_domains= ограничивает его доменами, которые НЕ определены параметром "=domainlist local_domains=" выше.  Восклицательный знак - это оператор отрицания.  Это правило позволяет пользователям отправлять исходящие сообщения на сайты, у которых есть косая черта и вертикальная черта в локальных частях.  Он блокирует локальные части, начинающиеся с точки, косой черты или вертикальной черты, но позволяет использовать эти символы в локальной части.  Однако последовательность =/../= запрещена.  Использование =@= =%= и =!= заблокировано, как и прежде. Это сделано для того, чтобы предотвратить некоторые виды атак на удаленные сайты со стороны ваших пользователей (или вирусов у ваших пользователей).

#+begin_src conf-unix 
  deny    message       = Restricted characters in address
          domains       = !+local_domains
          local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./
#+end_src

Принимать почту администратору почты (postmaster) в любом локальном домене, независимо от источника и без проверки отправителя.

#+begin_src conf-unix
  accept  local_parts   = postmaster
          domains       = +local_domains
#+end_src

Отклонить, если адрес отправителя не проходит проверку.

#+begin_src conf-unix
  require verify        = sender
#+end_src

Отклонять все команды RCPT после получения слишком большого числа неверных получателей. Это частично защита от спама и частично от атак. Мы считаем отправителя добросовестным, если к тому времени, как он выдаст 10 команд RCPT, по крайней мере половина из них будет реальными адресами.
  
Это несложная проверка, которая может предотвратить повторные вызовы более сложных проверок, которые последуют за ней.

#+begin_src conf-unix
  deny    condition     = ${if and {\
                        {>{$rcpt_count}{10}}\
                        {<{$recipients_count}{${eval:$rcpt_count/2}}} }}
          message       = Rejected for too many bad recipients
          logwrite      = REJECT [$sender_host_address]: bad recipient count high [${eval:$rcpt_count-$recipients_count}]
#+end_src

Принять, если сообщение приходит с одного из хостов, для которого мы выполняем исходящую ретрансляцию. Такие хосты, скорее всего, будут почтовыми клиентами (MUA), поэтому мы устанавливаем control=submission, чтобы Exim считал, что сообщение подано по протоколу submission. Тогда он будет исправлять различные ошибки в сообщении, например, отсутствие строки заголовка Date:. Если на самом деле выполняется ретрансляция сообщений от транспортных агентов (MTA), вы можете отключить эту настройку. Если вы производите как ретрансляцию от MTA, так и отправку от MUA, вам, вероятно, следует разделить их на два списка и обрабатывать их по-разному.

Проверка получателя здесь опущена, потому что многие MUA не справляются с ответами об ошибках SMTP. Если выполняется ретрансляция сообщений от MTA, вам, вероятно, следует добавить здесь проверку получателя.

Обратите внимание: если этот тест стоит перед проверкой черного списка DNS, то сообщения от этих хостов всегда будут приниматься, даже если они окажутся в черном списке. Предполагается, что они ваши друзья, и в черный список могут попасть только по ошибке.

#+begin_src conf-unix
  accept  hosts         = +relay_from_hosts
          control       = submission
          control       = dkim_disable_verify
#+end_src

Принять, если сообщение поступило по аутентифицированному соединению с любого хоста. Опять же, эти сообщения обычно исходят от MUA, поэтому проверка получателя опускается и устанавливается режим submission. И опять же, мы делаем эту проверку до проверок черных списков.

#+begin_src conf-unix
  accept  authenticated = *
          control       = submission
          control       = dkim_disable_verify
#+end_src

Требуем, чтобы хост отправлял нам HELO/EHLO.

#+begin_src conf-unix
  require message       = nice hosts say HELO first
          condition     = ${if def:sender_helo_name}
#+end_src

Требуем, чтобы все адреса получателя, которые мы принимаем, находились либо в одном из наших локальных доменов, либо в доменах, на которые мы явно разрешили ретрансляцию. Любой другой домен отклоняется как неприемлемый для ретрансляции.

#+begin_src conf-unix
  require message = relay not permitted
          domains = +local_domains : +relay_to_domains
#+end_src

Мы также требуем, чтобы все принятые адреса проходили проверку. Для локальных доменов здесь выполняется только проверка локальной части, а для удаленных доменов - только доменной. Единственный способ проверить локальные части для удаленных доменов — использовать =callout= (добавить =/callout=), но прежде чем делать это, ознакомьтесь с документацией о =callout=.

#+begin_src conf-unix
  require verify = recipient
#+end_src

В конфигурации по умолчанию нет проверки черных списков DNS , потому что местонахождение этих списков заранее неизвестно. Здесь приведено только два примера того, как заставить Exim выполнять поиск по черному списку DNS. Первый отказывает в приеме сообщения, а второй только выдает предупреждение.

#+begin_src conf-unix  
  # deny    dnslists      = black.list.example
  #         message       = rejected because $sender_host_address is in a black list at $dnslist_domain\n$dnslist_text
  #
  # warn    dnslists      = black.list.example
  #         add_header    = X-Warning: $sender_host_address is in a black list at $dnslist_domain
  #         log_message   = found in $dnslist_domain
#+end_src
  
Эта проверка закомментирована, так как очевидно, что не каждый системный администратор захочет ее делать. Если вы ее включите, то будет выполняться проверка авторизации клиента SMTP (Client SMTP Authorization, CSA) на хосте-отправителе. Эти проверки выполняют поиск записей SRV в DNS. Предложение CSA в настоящее время (май 2005 г.) находится в статусе проекта[fn:1]. Вы можете, конечно, добавить в этот оператор ACL дополнительные условия, чтобы делать проверку CSA только для определенных хостов.

#+begin_src conf-unix    
  # require verify = csa
#+end_src

Если выполняется фильтрация по содержимому для пользователей по отдельности, то всех получателей, для которых фильтры, отличаются от фильтров для первого получателя, нужно перевести в статус =defer=, если только отправитель не использует PRDR.

#+begin_src conf-unix    
  # defer  !condition     = $prdr_requested
  #        condition      = ${if > {0}{$receipients_count}}
  #        condition      = ${if !eq {$acl_m_content_filter} \
  #                                  {${lookup PER_RCPT_CONTENT_FILTER}}}
  # warn   !condition     = $prdr_requested
  #        condition      = ${if > {0}{$receipients_count}}
  #        set acl_m_content_filter = ${lookup PER_RCPT_CONTENT_FILTER}
#+end_src  

К данному моменту адрес прошел все проверки, которые были настроены, поэтому мы принимаем сообщение без дальнейших условий.

#+begin_src conf-unix    
  accept
#+end_src  

** Список контроля доступа =acl_check_prdr=

Этот ACL запускается по разу для каждого получателя для сообщений с несколькими получателями, если мы поддерживаем PRDR. Его можно использовать для выполнения фильтрации и отклонения сообщений на основе заголовка и тела в зависимости от получателя. Мы устанавливаем переменную, указывающую на использование PRDR, чтобы можно было пропустить соответствующую проверку в =acl_check_data=.

#+begin_src conf-unix    
.ifdef _HAVE_PRDR
acl_check_prdr:
  warn  set acl_m_did_prdr = y

  #############################################################################
  # do lookup on filtering, with $local_part@$domain, deny on filter match
  #
  # deny      set acl_m_content_filter = ${lookup PER_RCPT_CONTENT_FILTER}
  #           condition    = ...
  #############################################################################

  accept
.endif
#+end_src

** Cписок контроля доступа =acl_check_data=

Этот ACL запускается после получения содержимого сообщения. В этом ACL можно проверить заголовки или тело сообщения, и, в частности, здесь можно вызвать внешние сканеры вирусов или спама. Некоторые способы настройки этих проверок показаны ниже с комментариями. Если проверки не включены, этот ACL принимает все сообщения. Если вы хотите использовать проверки, то Exim должен быть скомпилирован с расширением сканирования контента (=WITH_CONTENT_SCAN=yes= в Local/Makefile).

#+begin_src conf-unix    
acl_check_data:
#+end_src

Отклонить, если сообщение содержит слишком длинные строки. Стандарты запрещают отправку таких сообщений через SMTP.

#+begin_src conf-unix    
  deny    condition  = ${if > {$max_received_linelength}{998}}
          message    = maximum allowed line length is 998 octets, \
                       got $max_received_linelength
#+end_src

Отклонить, если в заголовках есть неправильно сформированные адреса.

#+begin_src conf-unix    
  deny    !verify =     header_syntax
          message =     header syntax
          log_message = header syntax ($acl_verify_message)
#+end_src

Отклонить, если сообщение содержит вирус. Прежде чем включить эту проверку, вы должны установить антивирусный сканер и настроить параметр =av_scanner= выше.

#+begin_src conf-unix    
  # deny    malware    = *
  #         message    = This message contains a virus ($malware_name).
#+end_src

Добавить заголовки к сообщению, если оно расценено как спам. Перед включением этой проверки вы должны установить SpamAssassin. Также может понадобиться настроить параметр =spamd_address= в разделе основных настроек.

#+begin_src conf-unix    
  # warn    spam       = nobody
  #         add_header = X-Spam_score: $spam_score\n\
  #                      X-Spam_score_int: $spam_score_int\n\
  #                      X-Spam_bar: $spam_bar\n\
  #                      X-Spam_report: $spam_report
#+end_src

Если PRDR использовался, то больше никаких проверок.

#+begin_src conf-unix    
  # accept   condition  = ${if def:acl_m_did_prdr}
#+end_src

Если мы добрались сюда, значит, для всех получателей сообщений используется одинаковая фильтрация по содержимому в зависимости от пользователя (обеспечивается RCPT ACL). Выполнить поиск фильтра и отклонить сообщение при совпадении.

#+begin_src conf-unix    
  # deny      set acl_m_content_filter = ${lookup PER_RCPT_CONTENT_FILTER}
  #           condition    = ...
#+end_src

Принять сообщение.

#+begin_src conf-unix    
  accept
#+end_src

* Конфигурация маршрутизаторов

Указывает, как обрабатываются адреса.

*ПОРЯДОК, В КОТОРОМ ПЕРЕЧИСЛЕНЫ МАРШРУТИЗАТОРЫ, ВАЖЕН!*

Адрес передается каждому маршрутизатору по очереди, пока он не будет принят.

#+begin_src conf-unix
begin routers
#+end_src

** Маршрутизатор =domain_literal=
    
Этот маршрутизатор направляет почту на удаленные хосты через SMTP, используя явно указанный IP-адрес, если адрес электронной почты указан в форме «буквального домена», например, =<user@[192.168.35.64]>=. Этого требуют RFC. Однако в наши дни такой способ малоизвестен и нередко применяется злоумышленниками, пытающимися использовать SMTP-ретрансляторы. Поэтому он закомментирован в конфигурации по умолчанию. Если вы раскомментируете этот маршрутизатор, вам также нужно будет раскомментировать параметр =allow_domain_literals= выше, чтобы Exim мог распознавать синтаксис буквальных доменов.
    
#+begin_src conf-unix
# domain_literal:
#   driver = ipliteral
#   domains = ! +local_domains
#   transport = remote_smtp
#+end_src

** Маршрутизация в зависимости от отправителя

Здесь описан маршрутизатор, выбирающий транспорт в зависимости
от идентификатора пользователя по правилам, описанным в
=/etc/exim/smarthosts=.  Опция =route_list= не будет использоваться
транспортом, так как в нем будет установлено =hosts_override =
true=. =SMARTHOST_TRANSPORT= извлекает первое поле из строки в файле
=/etc/exim4/smarthosts=, ключом при этом является =$authenticated_id=,
то есть имя, под которым пользователь авторизовался, отправляя письмо
на наш локальный сервер.

#+BEGIN_SRC conf-unix
  SMARTHOST_TRANSPORT = ${extract{1}{:}{${lookup{$authenticated_id}nwildlsearch{CONFDIR/smarthosts}{$value}}}}

  smarthost_multi:
      debug_print = "R: smarthost_multi for $local_part@$domain  $authenticated_id"
      driver = manualroute
      condition =  ${if eq {SMARTHOST_TRANSPORT}{}{no}{yes}}
      domains = !+local_domains
      route_list = "* $domain"
      transport = SMARTHOST_TRANSPORT
      ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; ::1
      host_find_failed = ignore
      same_domain_copy_routing = yes
#+END_SRC 

Если адрес не найдется в файле =CONFDIR/smarthosts=, он будет передан следующему маршрутизатору, которым будет =smarthost=.

** Маршрутизатор =smarthost=

Этот маршрутизатор можно использовать, если вы хотите отправлять всю почту на сервер, который сам будет работать с DNS. Интернет-провайдеры обычно предоставляют такие серверы своим клиентам. Имя хоста в =route_data= берется из макроса, определенного в самой верхней части этого файла. Если он не определен, вместо этого будет использоваться следующий указанный ниже маршрутизатор.

Помните, что имя хоста может быть еще раз указано в разделе транспортов.

#+begin_src conf-unix
  .ifdef ROUTER_SMARTHOST

  smarthost:
    debug_print = "R: smarthost for $local_part@$domain"
    driver = manualroute
    domains = ! +local_domains
    transport = remote_smtp_smarthost
    route_data = ROUTER_SMARTHOST
    ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; ::1
    no_more

  .endif
#+end_src

Если =ROUTER_SMARTHOST= не указан, сообщение передается маршрутизатору =dnslookup=.

** Маршрутизатор =dnslookup=

Этот маршрутизатор направляет почту по адресам, которые не принадлежат локальным доменам, выполняя поиск DNS по имени домена. Восклицательный знак в "=domains = ! +local_domains=" является оператором отрицания. Его можно читать как "не": то есть, для того, чтобы этот маршрутизатор работал, домен получателя не должен быть одним из тех, которые определены в "=domainlist local_domains=".

Если этот маршрутизатор работает, любой домен, который разрешается в =0.0.0.0= или в адрес интерфейса обратной связи (loopback) (=127.0.0.0/8=), обрабатывается так, как если бы он не имел записи DNS. Обратите внимание, что =0.0.0.0= совпадает с =0.0.0.0/32=, который обычно в сетевом стеке рассматривается как локальный хост. Это не =0.0.0.0/0=, маршрут по умолчанию. Если поиск в DNS завершается неудачей, дальнейшие попытки маршрутизации не предпринимаются из-за параметра =no_more=. Таким образом, адрес считается немаршрутизириуемым.

В Debian имеется параметр =ROUTER_DNSLOOKUP_IGNORE_TARGET_HOSTS=, который по умолчанию имеет вид = <; 0.0.0.0 ; 127.0.0.0/8 ; 192.168.0.0/16 ; 172.16.0.0/12 ; 10.0.0.0/8 ; 169.254.0.0/16 ; 255.255.255.255 ; ::/128 ; ::1/128 ; fc00::/7 ; fe80::/10 ; 100::/64. Это значит, что для  адресов локальной сети DNS не используется. Но в такой сети DNS вполне может работать с локальными доменами, и поэтому здесь мы ограничимся только интерфейсом локального хоста и loopback.

#+begin_src conf-unix
  dnslookup:
    debug_print = "R: dnslookup for $local_part@$domain"
    driver = dnslookup
    domains = ! +local_domains
    transport = remote_smtp
  #  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  # if ipv6-enabled then instead use:
    ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; ::1
    no_more

#+end_src

Остальные маршрутизаторы обрабатывают адреса в локальном домене (доменах), то есть в тех доменах, которые определены выше в =domainlist local_domains=.

** Маршрутизатор =system_aliases=
    
Этот маршрутизатор обрабатывает псевдонимы, используя линейный поиск в файле псевдонимов с именем =/etc/aliases=. При автоматической конфигурации имя файла берется из настроек сборки Exim. Путь по умолчанию — традиционный =/etc/aliases=. Если вы делаете конфигурацию вручную, необходимо указать правильный путь в параметре =data=.

Файл псевдонимов должен существовать. Раньше этот файл был в любой Unix-системе, потому что использовался по умолчанию в Sendmail. В наши дни встречаются системы, в которых его нет. Ваш файл псевдонимов должен как минимум содержать псевдоним для =postmaster=.
  
Если для псевдонимов заданы файлы или конвейеры, нужно будет настроить пользователя и группу, под которыми они будут работать. Это можно сделать, раскомментировав параметр =user= ниже (изменив имя пользователя соответствующим образом) и добавив параметр =group=, если необходимо. Вместо этого можно указать =user= в описании транспортов. Обратите внимание, что перечисленные ниже транспорты - те же, что и для файлов =.forward=. Возможно, для файлов и конвейеров нужно будет захотите настроить разные транспорты.

#+begin_src conf-unix     
  system_aliases:
    driver = redirect
    domains = +local_domains
    allow_fail
    allow_defer
    data = ${lookup{$local_part}lsearch{/etc/aliases}}
  # user = exim
    file_transport = address_file
    pipe_transport = address_pipe
#+end_src

** Маршрутизатор =userforward=

Этот маршрутизатор обрабатывает пересылку по адресам в традиционных файлах =.forward= в домашних каталогах пользователей. Если вы хотите разрешить фильтрацию почты (для этого файл =.forward= должен начинаться со строки =# Exim filter= или =# Sieve filter=), раскомментируйте параметр =allow_filter=.

Параметр =no_verify= означает, что этот маршрутизатор пропускается, когда Exim проверяет адреса. Аналогично, =no_expn= означает, что этот маршрутизатор пропускается, если Exim обрабатывает команду EXPN.

Если вы хотите, чтобы этот маршрутизатор обрабатывал локальные части с суффиксами, отделенными символами =-= или =+=, так, как если бы эти суффиксы не существовали, раскомментируйте два параметра =local_part_suffix=. Тогда, например, =xxxx-foo@your.domain= будет обрабатываться этим маршрутизатором так же, как =xxxx@your.domain=. Поскольку этот маршрутизатор не используется для проверки, то если вы решите раскомментировать эти параметры, вам *обязательно* придется внести такие же изменения в маршрутизатор localuser. (Есть и другие подходы, если это нежелательно, но они добавляют сложности).

Параметр =check_ancestor= означает, что если файл =.forward= cгенерирует адрес, являющийся предком текущего, вместо него передается текущий. Так будут обрабатываться случаи, когда A сделан псевдонимом B, а у B есть файл =.forward=, указывающий на A.

Три транспорта, указанные в конце, используются, когда файл =.forward= генерирует прямую доставку в файл, или в конвейер, или настраивает автоматический ответ соответственно.

#+begin_src conf-unix      
  userforward:
    driver = redirect
    check_local_user
    domains = +local_domains
  # local_part_suffix = +* : -*
  # local_part_suffix_optional
    file = $home/.forward
    require_files = $local_part_data:$home/.forward
  # allow_filter
    no_verify
    no_expn
    check_ancestor
    file_transport = address_file
    pipe_transport = address_pipe
    reply_transport = address_reply
#+end_src     

** Маршрутизатор =localuser=

Этот маршрутизатор отправляет сообщения в почтовые ящики локальных пользователей. Если в маршрутизатор не может обработать сообщение, выдается сообщение об ошибке "Unknown user".

Если вы хотите, чтобы этот маршрутизатор обрабатывал локальные части с суффиксами, отделенными символами =-= или =+=, так, как если бы эти суффиксы не существовали, раскомментируйте два параметра =local_part_suffix=. Тогда, например, =xxxx-foo@your.domain= будет обрабатываться этим маршрутизатором так же, как =xxxx@your.domain=. 

#+begin_src conf-unix      
  localuser:
    driver = accept
    check_local_user
    domains = +local_domains
  # local_part_suffix = +* : -*
  # local_part_suffix_optional
    transport = mail_spool
    cannot_route_message = Unknown user
#+end_src

* Конфигурация транспортов

*ПОРЯДОК НЕ ВАЖЕН*

Для каждой доставки вызывается только один подходящий транспорт. Транспорт используется только при обращении с маршрутизатора, который успешно обработал адрес.

#+begin_src conf-unix      
begin transports
#+end_src

** Прямая доставка через SMTP

Этот транспорт используется для доставки сообщений через SMTP-соединения. Не допускается отправка сообщений со слишком длинными строками, которые могли быть получены не через SMTP. Использование =message_size_limit= для обеспечения соблюдения этого правила может ввести в заблуждение.

Именно здесь настраиваются параметры DKIM, использования шифрования TLS и другие параметры, необходимые для того, чтобы удаленный SMTP-сервер согласился принять сообщение и не отправил его в спам.

#+begin_src conf-unix      
  remote_smtp:
    debug_print = "T: remote_smtp for $local_part@$domain"
    driver = smtp
    message_size_limit = ${if > {$max_received_linelength}{998} {1}{0}}
#+end_src

** Доставка на смарт-хост по умолчанию

Этот транспорт используется для доставки сообщений на смарт-хост, если сработал маршрутизатор =smarthost=.  В основе его транспорт =remote_smtp=, но затем подключаются различные параметры безопасности, потому что, как мы предполагаем, смарт-хост будет поддерживать TLS, иметь проверяемый сертификат для своего имени и набор хороших шифров TLS.

Для примера здесь также установлен параметр для использования порта подключения 587 вместо 25.
   
#+begin_src conf-unix      
  remote_smtp_smarthost:
    debug_print = "T: remote_smtp_smarthost for $local_part@$domain"
    driver = smtp
    multi_domain
    hosts_try_auth = <; ${if exists{CONFDIR/passwd.client} \
	{\
	${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$host_address}}\
	}\
	{} \
      }
    port = 587
    hosts_require_tls = *
    tls_verify_hosts = *
    tls_sni = ROUTER_SMARTHOST
#+end_src

** Доставка на индивидуально настраиваемые смарт-хосты

Эти транспорты используется для доставки сообщений на смарт-хосты по правилам маршрутизации в зависимости от отправителя, если сработал маршрутизатор =smarthost_multi=.
   
Для каждого сервера мы создадим отдельный транспорт, работающий по протоколу SMTP.  Обратите внимание, что для Mail.ru нужно указать =port = 465= и =protocol = smtps=, а Gmail работает с =port = 587=. Про порты и протоколы можно почитать, например, [[https://habr.com/ru/articles/495256/][здесь]].

#+begin_src conf-unix      
  mailru:
      # См. https://help.mail.ru/mail/mailer/popsmtp
      debug_print = "T:  mailru for $local_part@$domain"
      driver = smtp
      hosts = smtp.mail.ru
      hosts_override = true
      helo_data = localhost
      port = 465
      protocol = smtps
      hosts_require_auth = *
      hosts_require_tls = *
      tls_verify_hosts = *

  gmail:
      # См. https://support.google.com/mail/answer/7126229
      debug_print = "T:  gmail for $local_part@$domain"
      driver = smtp
      hosts = smtp.gmail.com
      hosts_override = true
      helo_data = localhost
      port = 587
      hosts_require_auth = *
      hosts_require_tls = *
      tls_verify_hosts = *

  yandex:
      # См. https://yandex.ru/support/mail/mail-clients/others.html	
      debug_print = "T:  yandex for $local_part@$domain"
      driver = smtp
      hosts = smtp.yandex.ru
      hosts_override = true
      helo_data = localhost
      port = 465
      protocol = smtps
      hosts_require_auth = *
      hosts_require_tls = *
      tls_verify_hosts = *

  ms:
      # См. https://support.microsoft.com/ru-ru/office/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-pop-imap-%D0%B8-smtp-%D0%B4%D0%BB%D1%8F-outlook-com-d088b986-291d-42b8-9564-9c414e2aa040	
      debug_print = "T:  ms for $local_part@$domain"
      driver = smtp
      hosts = smtp-mail.outlook.com
      hosts_override = true
      helo_data = localhost
      port = 587
      hosts_require_auth = *
      hosts_require_tls = *
      tls_verify_hosts = *
#+end_src 

В этом файле в том же формате описаны дополнительные смарт-хосты, информация о которых не предназначена для общего пользования.

#+begin_src conf-unix
{% include 'secrets/40_smarthosts' ignore missing %}
#+end_src 


** Локальная доставка в mailbox

Этот транспорт используется для локальной доставки в почтовые ящики пользователей в традиционном формате почтовых ящиков BSD. По умолчанию он будет запущен под uid и gid локального пользователя и требует установки бита закрепления на каталоге =/var/mail=. Некоторые системы используют альтернативный подход к доставке почты в определенную группу вместо использования бита закрепления. Закоментированные варианты показывают, как это можно сделать.

#+begin_src conf-unix 
  mail_spool:
    debug_print = "T: appendfile for $local_part@$domain"
    driver = appendfile
    file = /var/mail/$local_part_data
    delivery_date_add
    envelope_to_add
    return_path_add
  # group = mail
  # mode = 0660
#+end_src

** Локальная доставка через конвейеры

Этот транспорт используется для доставки через конвейеры, созданные псевдонимами или файлами =.forward=. Если конвейер запишет что-нибудь на стандартный вывод, текст будет возвращен отправителю сообщения как ошибка доставки. Установите =return_fail_output= вместо =return_output=, если вы хотите, чтобы это происходило только тогда, когда конвейер не смог нормально завершиться. При желании вы можете настроить разные транспорты для псевдонимов и =.forward=, см. =address_pipe= в разделе маршрутизаторов выше.

#+begin_src conf-unix   
  address_pipe:
    debug_print = "T: address_pipe for $local_part@$domain"
    driver = pipe
    return_fail_output
#+end_src

** Локальная доставка в файлы

Этот транспорт используется для доставки через конвейеры, созданные псевдонимами или файлами =.forward=.    

#+begin_src conf-unix   
  address_file:
    debug_print = "T: address_file for $local_part@$domain"
    driver = appendfile
    delivery_date_add
    envelope_to_add
    return_path_add
#+end_src

** Автоответ

Этот транспорт используется для автоответов, сгенерированных опцией фильтрации маршрутизатора =userforward=.

#+begin_src conf-unix   
  address_reply:
    debug_print = "T: autoreply for $local_part@$domain"
    driver = autoreply
#+end_src

* Конфигурация повторных попыток доставки
      
Здесь описано единственное правило повторных попыток доставки, общее для всех доменов и всех ошибок. Повторные попытки предпринимаются каждые 15 минут в течение 2 часов, затем интервалы повторных попыток увеличиваются, начиная с 1 часа и увеличиваясь каждый раз в 1,5 раза, доходят до 16 часов, затем повторяются каждые 6 часов, пока не пройдет 4 дня с момента первой неудачной доставки.

ПРЕДУПРЕЖДЕНИЕ: Если у вас вообще нет правил повторных попыток (то есть этот раздел конфигурации не существует или пустой), Exim не будет делать никаких повторных попыток доставки сообщений, которые не были доставлены с первой попытки. В результате временные ошибки будут рассматриваться как постоянные. Поэтому НЕ удаляйте это правило повторных попыток, если только вы действительно не хотите никаких повторных попыток.

#+begin_src conf-unix      
  begin retry
    # Address or Domain    Error       Retries
    # -----------------    -----       -------
    #  *                    *           F,2h,15m; G,16h,1h,1.5; F,4d,6h
#+end_src  

* Конфигурация переписывания заголовков

В этом файле конфигурации по умолчанию нет переписывания заголовков.
   
#+begin_src conf-unix
  begin rewrite
	#$local_part@$domain $header_from:  Frs
#+end_src

* Конфигурация аутентификаторов
#+begin_src conf-unix
begin authenticators
#+end_src

** Exim в качестве сервера

Эти аутентификаторы работают, когда Exim выполняет функцию сервера, принимая соединения от клиентов, которыми могут быть как MUA (обычные программы-клиенты электронной почты), так и MTA (другие серверы, доставляющие нам почту).

Хосты, которым разрешено использовать AUTH, определяются параметром =auth_advertise_hosts= в основной конфигурации. Значение по умолчанию — =*=, что разрешает аутентификацию всем хостам по всем типам соединений, если здесь определен хотя бы один аутентификатор.

Аутентификаторы, которые используют незашифрованные пароли, передаваемые в виде открытого текста, по умолчанию не объявляются при незашифрованном соединении. Для этого служит параметр =server_advertise_condition=. Для поддержки зашифрованных соединений следует настроить TLS.

Следующие аутентификаторы поддерживают аутентификацию с передачей имени пользователя/пароля простым текстом по стандартному механизму PLAIN, а также по традиционному, но нестандартному механизму LOGIN. Суффикс =_server= в названиях аутентификаторов указывает на то, что Exim выполняет функции сервера. Механизмов PLAIN и LOGIN достаточно для поддержки большинства программ-клиентов электронной почты.

Вся логика проверки паролей программируется в параметре =server_condition=. Эта логика записывается в виде выражения, подлежащего расширению. В нем могут быть сравнения, поиск в файлах, базах данных и т.д.

Аутентификаторы настроены так, чтобы предлагать аутентификацию клиенту только в том случае, если соединение зашифровано с помощью TLS. Поэтому нужно включить поддержку TLS. Дополнительные сведения о TLS см. в разделе параметров глобальной конфигурации в начале этого файла.

В списке контроля доступа =acl_check_rcpt= есть условие, которое позволяет принимать сообщения от аутентифицированных пользователей откуда угодно в Интернете.

=server_advertise_condition= контролирует объявление отдельных механизмов аутентификации. Например, его можно использовать для того, чтобы заявлять о поддержке определенного механизма шифрования соединений. Если сессия зашифрована, =$tls_in_cipher= не пуста, поэтому расширение дает =*=, что позволяет объявить о поддержке.

Для аутентификации методом PLAIN не требуются запросы сервера.  Клиент отправляет свои учетные данные одним пакетом, содержащим идентификатор авторизации (который далее не используется), идентификатор аутентификации и пароль. Последние два отображаются в конфигурации как =$auth2= и =$auth3=. Мы проверяем их на соответствие фактическому имени пользователя и паролю. В реальных условиях обычно =$auth2= (идентификатор аутентификации) используется в качестве ключа поиска (например, в файле паролей). Если поиск дал результат (обычно это пароль или хэш пароля), мы сравниваем его с =$auth3=, возможно, используя функцию =crypteq{}{}=.

Чем отличаются идентификатор авторизации (authorization id или AuthZ) и идентификатор аутентификации (authentication id или AuthN)? Идентификатор аутентификации - это имя пользователя, с чьим паролем осуществляется вход. Идентификатор авторизации - это имя, под которым пользователь будет работать в системе (если, конечно, пользователю, с чьим паролем был осуществлен вход, разрешено работать с таким именем). При управлении доступом на основе ролей (RBAC) идентификатором авторизации может быть роль. В элементарных условиях, заданных в нижеследующих аутентификаторах, идентификатор авторизации не используется.

Идентификаторы устанавливает драйвер аутентификатора: =plaintext=,  =cyrus_sasl= и так далее.

#+begin_src conf-unix
  plain_server:
    driver = plaintext
    public_name = PLAIN
    server_condition = "${if crypteq{$auth3}{${extract{1}{:}{${lookup{$auth2}lsearch{CONFDIR/passwd}{$value}{*:*}}}}}{1}{0}}"
    server_set_id = $auth2
    server_prompts = :
    server_advertise_condition = ${if eq{$tls_in_cipher}{}{}{*}}
#+end_src

В аутентификации методом LOGIN используются традиционные запросы и ответы. В этом механизме нет идентификатора авторизации, поэтому, в отличие от PLAIN, имя пользователя и пароль — $auth1 и $auth2. Параметр =server_advertise_condition= подходит для обоих аутентификаторов.

#+begin_src conf-unix
  login_server:
    driver = plaintext
    public_name = LOGIN
    server_prompts = "Username:: : Password::"
    server_condition = "${if crypteq{$auth2}{${extract{1}{:}{${lookup{$auth1}lsearch{CONFDIR/passwd}{$value}{*:*}}}}}{1}{0}}"
    server_set_id = $auth1
    server_advertise_condition = ${if eq{$tls_in_cipher}{}{}{*}}
#+end_src

В конфигурации Debian в файле =auth/30_exim4-config_examples= приведен ряд примеров аутентификаторов с различными механизмами.

** Exim в качестве клиента

Эти аутентификаторы работают, когда Exim выполняет функцию клиента, отправляя почту на другие серверы.

Это единственное место, где в конфигурацию внесены изменения. Извлечение логина и пароля для сервера производится в два шага. Сначала по *имени пользователя*, отправившего письмо (=$authenticated_id=) в =CONFDIR/passwd.smarthosts= ищется логин и пароль для смартхоста, на который должна отправляться почта от этого пользователя. Маршрутизатор =smarthost_multi= должен был направить письмо именно туда. Если там такого имени пользователя не найдено, используется традиционный механизм поиска *имени хоста* в =CONFDIR/passwd.client= и извлечения логина и пароля оттуда.

Затем в найденной строке все =^= заменяются на =^^=. Это нужно, потому что в драйвере =plaintext= одиночные =^= заменяются на =NUL= (разделители). Символ =:= в логине недопустим, а в пароле - допустим.

Полученная строка =PASSWDLINE= состоит из логина и пароля, разделенных =:=. Она и используется в аутентификаторах.

Выражения взяты из конфигурации Debian.

#+begin_src conf-unix    
PLINE=${lookup{$authenticated_id}nwildlsearch{CONFDIR/passwd.smarthosts}{$value}{}}
PASSWDLINE=${if eq{PLINE}{}{${sg{\
               ${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}\
               }\
               {\\N[\\^]\\N}\
               {^^}\
           }}{${sg{PLINE}{\\N[\\^]\\N}{^^}}}}
#+end_src
   
Поскольку =AUTH PLAIN= и =AUTH LOGIN= отправляют пароль в открытом виде, по умолчанию мы разрешаем эти механизмы только для зашифрованных соединений (проверяя, установлена ли переменная =$tls_out_cipher=).

Механизм PLAIN (RFC 2595) требует отправки трех значений, разделенных =NUL=. Первое значение - идентификатор авторизации, второе - идентификатор аутентификации, третье - пароль. Пустое первое значение означает, что идентификатор авторизации совпадает с идентификатором аутентификации. (=<;= - синтаксис Exim для смены разделителя списка на =;=).

#+begin_src conf-unix    
plain:
  driver = plaintext
  public_name = PLAIN
  client_send = "<; ${if !eq{$tls_out_cipher}{}\
                    {^${extract{1}{:}{PASSWDLINE}}\
		     ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}\
		   }fail}"
#+end_src

Выражение в =client_send= возвращает пустую строку, если соединение зашифровано и в одном из файлов нашелся логин и пароль. В противном случае оно возвращает =fail=, и расширение не удается.

#+begin_src conf-unix        
login:
  driver = plaintext
  public_name = LOGIN
  client_send = "<; ${if and{\
                          {!eq{$tls_out_cipher}{}}\
                          {!eq{PASSWDLINE}{}}\
                         }\
                      {}fail}\
                 ; ${extract{1}{::}{PASSWDLINE}}\
		 ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
#+end_src


* Footnotes
[fn:1] В настоящее время (июнь 2023 года) механизм Client SMTP Authorization нигде не используется. Черновик стандарта устарел.
